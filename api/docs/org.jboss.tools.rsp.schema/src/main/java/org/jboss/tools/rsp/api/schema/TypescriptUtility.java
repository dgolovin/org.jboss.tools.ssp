/*******************************************************************************
 * Copyright (c) 2018 Red Hat, Inc. Distributed under license by Red Hat, Inc.
 * All rights reserved. This program is made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is
 * available at http://www.eclipse.org/legal/epl-v20.html
 * 
 * Contributors: Red Hat, Inc.
 ******************************************************************************/
package org.jboss.tools.rsp.api.schema;

import java.io.File;
import java.io.IOException;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.Node;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.comments.JavadocComment;
import com.github.javaparser.ast.expr.AnnotationExpr;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

import cz.habarta.typescript.generator.Input;
import cz.habarta.typescript.generator.JsonLibrary;
import cz.habarta.typescript.generator.Output;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.TypeScriptOutputKind;

public class TypescriptUtility {

	private static final String PROTOCOL_TYPE_FILE = "protocol.unified.d.ts";
	private static final String TS_TYPE_FILE_SUFFIX = ".d.ts";

	private String baseDir;

	public TypescriptUtility(String baseDir) {
		this.baseDir = baseDir;
	}

	public void writeTypescriptSchemas(Class<?>[] daoClasses) throws IOException {
		if( daoClasses == null || daoClasses.length == 0 ) {
			// TODO error somehow? 
			return;
		}
		
		URLClassLoader cl = (URLClassLoader) daoClasses[0].getClassLoader();
		
		File daoFolder = getDaoTypescriptFolder().toFile();
		if (!daoFolder.exists()) {
			daoFolder.mkdirs();
		}

		final Settings settings = new Settings();
		settings.outputKind = TypeScriptOutputKind.module;
		settings.jsonLibrary = JsonLibrary.jackson2;
		String[] clazNames = new String[daoClasses.length];
		for (int i = 0; i < daoClasses.length; i++) {
			writeTypescriptType(daoClasses[i], settings);
			clazNames[i] = daoClasses[i].getName();
		}		

		File output = getUnifiedSchemaFile();
		new TypeScriptGenerator(settings).generateTypeScript(
				Input.fromClassNamesAndJaxrsApplication(
						Arrays.asList(clazNames), null, null, false, null, cl, true), 
				Output.to(output));
	}
	
	public File getUnifiedSchemaFile() {
		return getDaoTypescriptFolder().resolve(PROTOCOL_TYPE_FILE).toFile();
	}

	private void writeTypescriptType(Class<?> clazz, final Settings settings) throws IOException {
		Path p = getDaoTypescriptFile(clazz.getSimpleName());
		File output = p.toFile();
		List<String> classes = Arrays.asList(clazz.getName());

		new TypeScriptGenerator(settings).generateTypeScript(
				Input.fromClassNamesAndJaxrsApplication(
						classes, null, null, false, null, (URLClassLoader) clazz.getClassLoader(), true),
				Output.to(output));
		
		// It loads the files with stupid autogenerated garbage
		String contents = safeReadFile(p);
		String trimmed = trimFirstLines(contents);
		Files.write(p, trimmed.getBytes());
	}

	private static String trimFirstLines(String contents) {
		int beginning = -1;
		for( int i = 0; i < 3; i++ ) {
			beginning = contents.indexOf('\n', beginning + 1);
			if( beginning == -1 ) {
				return "";
			}
		}
		return contents.substring(beginning).trim();
	}

	public Path getDaoTypescriptFile(String simpleClassName) {
		Path folder = getDaoTypescriptFolder();
		Path out = folder.resolve(simpleClassName + TS_TYPE_FILE_SUFFIX);
		return out;
	}

	public Path getDaoTypescriptFolder() {
		return new File(baseDir).toPath()
				.resolve("src").resolve("main").resolve("resources").resolve("schema").resolve("typescript");
	}

	public void cleanFolder() {
		Path folder = getDaoTypescriptFolder();
		File[] ts = folder.toFile().listFiles();
		for( int i = 0; i < ts.length; i++ ) {
			ts[i].delete();
		}
	}

	private static String safeReadFile(Path p) {
		if(p.toFile().exists()) {
			try {
				String content = new String(Files.readAllBytes(p));
				return content;
			} catch(IOException ioe) {
				// return ""
			}
		}
		return "";
	}

	public void generateTypescriptClient(String dir) {
		generateProtocolTs(dir);
		generateMessageTs(dir);
		generateIncomingTs(dir);
	}
	
	private void generateProtocolTs(String dir) {
		File existing = getUnifiedSchemaFile();
		File destination = new File(dir).toPath().resolve("src").resolve("protocol").resolve("protocol.ts").toFile();
		String contents = readFile(existing);
		String header = 
				"/**\n" + 
				" * Json objects sent between the server and the client\n" + 
				" */\n" + 
				"export namespace Protocol {\n";
		String footer = "}";
		
		String total = header + linePrefix(contents, "    ") + footer;
		try {
			Files.write(destination.toPath(), total.getBytes());
		} catch(IOException ioe) {
			
		}
	}
	
	private void generateMessageTs(String dir) {
		File destination = new File(dir).toPath().resolve("src").resolve("protocol").resolve("messages.ts").toFile();
		String fileContents = messageTsHeader() + messageTsServer() + messageTsClient() + messageTsFooter();
		try {
			Files.write(destination.toPath(), fileContents.getBytes());
		} catch(IOException ioe) {
			
		}
	}

	private void generateIncomingTs(String dir) {
		File destination = new File(dir).toPath().resolve("src").resolve("util").resolve("incoming.ts").toFile();
		String fileContents = incomingTsHeader() + incomingTsClient() + incomingTsFooter();
		try {
			Files.write(destination.toPath(), fileContents.getBytes());
		} catch(IOException ioe) {
			
		}
	}
	
	private String incomingTsHeader() {
		return "import { Protocol } from '../protocol/protocol';\n" + 
				"import { Messages } from '../protocol/messages';\n" + 
				"import { MessageConnection } from 'vscode-jsonrpc';\n" + 
				"import { EventEmitter } from 'events';\n" + 
				"\n" + 
				"/**\n" + 
				" * Server incoming\n" + 
				" */\n" + 
				"export class Incoming {\n" + 
				"\n" + 
				"    private connection: MessageConnection;\n" + 
				"    private emitter: EventEmitter;\n" + 
				"\n" + 
				"    /**\n" + 
				"     * Constructs a new discovery handler\n" + 
				"     * @param connection message connection to the RSP\n" + 
				"     * @param emitter event emitter to handle notification events\n" + 
				"     */\n" + 
				"    constructor(connection: MessageConnection, emitter: EventEmitter) {\n" + 
				"        this.connection = connection;\n" + 
				"        this.emitter = emitter;\n" + 
				"        this.listen();\n" + 
				"    }\n" + 
				"";
	}

	private String incomingTsFooter() {
		return "}";
	}

	private String incomingTsListen() {
		String header = "    /**\n" + 
				"     * Subscribes to notifications sent by the server\n" + 
				"     */\n" + 
				"    private listen() {\n";
		String footer = "}";
		
		StringBuffer sb = new StringBuffer();
		try {
			Map<String, JavadocComment> map = methodToJavadocMap(getClientInterfaceFile());
			List<String> names = new ArrayList<>(map.keySet());
			String[] methods = names.toArray(new String[names.size()]);
			for( int i = 0; i < methods.length; i++ ) {
				JavadocComment jdc = map.get(methods[i]);
				MethodDeclaration md = getMethodDeclaration(jdc);
				if( isNotification(md) ) {
					
					String methodName = md.getNameAsString();
					String notificationName = methodNameToNotificationName(methodName);
					
					sb.append("        this.connection.onNotification(Messages.Client." + notificationName + ".type, param => {\n");
					sb.append("            this.emitter.emit('" + methodName + "', param);\n");
					sb.append("        });\n\n");
					
				} else {

				}
			}
		} catch(IOException ioe) {
			throw new RuntimeException(ioe);
		}

		
		
		return header + sb.toString() + footer;
	}
	

	private String incomingTsRegisterListeners() {
		StringBuffer sb = new StringBuffer();
		try {
			Map<String, JavadocComment> map = methodToJavadocMap(getClientInterfaceFile());
			List<String> names = new ArrayList<>(map.keySet());
			String[] methods = names.toArray(new String[names.size()]);
			for( int i = 0; i < methods.length; i++ ) {
				JavadocComment jdc = map.get(methods[i]);
				MethodDeclaration md = getMethodDeclaration(jdc);

				String methodName = md.getNameAsString();
				String capName = capFirstLetter(methodName);
				int paramCount = md.getParameters().size();
				String paramType = paramCount > 0 ? convertReturnType(md.getParameter(0).getType().toString()) : null;
				Type retType = md.getType();
				String retTypeName = convertReturnType(retType.toString());

				if( isNotification(md) ) {
					sb.append("    on" + capName + "(listener: (arg: " + paramType + ") => " + retTypeName + "): void\n    {\n");
					sb.append("        this.emitter.on('" + methodName + "', listener);\n");
					sb.append("    }\n");
				} else {
					String requestName = methodNameToRequestName(methodName);
					sb.append("    on" + capName + "(listener: (arg: " + paramType + ") => Promise<" + retTypeName + ">): void\n    {\n");
					sb.append("        this.connection.onRequest(Messages.Client." + requestName + ".type, listener);\n");
					sb.append("    }\n");
				}
			}
		} catch(IOException ioe) {
			throw new RuntimeException(ioe);
		}
		
		return sb.toString();
	}
	
	private String incomingTsClient() {
		return incomingTsListen() + "\n\n" + incomingTsRegisterListeners();
	}
	
	private String messageTsHeader() {
		return "import { NotificationType, RequestType } from 'vscode-jsonrpc';\n" + 
				"import { Protocol } from './protocol';\n" + 
				"\n" + 
				"/**\n" + 
				" * Message types sent between the RSP server and the client\n" + 
				" */\n" + 
				"export namespace Messages {\n";
	}
	
	private String messageTsServer() {
		String header = "\n" + 
				"    /**\n" + 
				"     * Server methods\n" + 
				"     */\n" + 
				"    export namespace Server {\n\n";
		String footer = "    }\n";
		
		StringBuffer sb = new StringBuffer();
		try {
			Map<String, JavadocComment> map = methodToJavadocMap(getServerInterfaceFile());
			List<String> names = new ArrayList<>(map.keySet());
			String[] methods = names.toArray(new String[names.size()]);
			
			for( int i = 0; i < methods.length; i++ ) {
				JavadocComment jdc = map.get(methods[i]);
				if( isNotification(getMethodDeclaration(jdc)) ) {
					printOneNotification(methods[i], jdc, sb, "server");
				} else {
					printOneRequest(methods[i], jdc, sb, "server");
				}
			}
		} catch(IOException ioe) {
			throw new RuntimeException(ioe);
		}
		
		return header + sb.toString() + footer;
	}

	private String messageTsClient() {
		StringBuffer sb = new StringBuffer();
		sb.append("    /**\n" + 
				"     * Client methods\n" + 
				"     */\n" + 
				"    export namespace Client {\n");
		
		
		try {
			Map<String, JavadocComment> map = methodToJavadocMap(getClientInterfaceFile());
			List<String> names = new ArrayList<>(map.keySet());
			String[] methods = names.toArray(new String[names.size()]);
			for( int i = 0; i < methods.length; i++ ) {
				JavadocComment jdc = map.get(methods[i]);
				if( isNotification(getMethodDeclaration(jdc)) ) {
					printOneNotification(methods[i], jdc, sb, "client");
				} else {
					printOneRequest(methods[i], jdc, sb, "client");
				}
			}
		} catch(IOException ioe) {
			throw new RuntimeException(ioe);
		}

		
		
		sb.append("    }\n");
		return sb.toString();
	}

	private boolean isNotification(MethodDeclaration dec) {
		NodeList<AnnotationExpr> annotations = dec.getAnnotations();
		for( AnnotationExpr a : annotations) {
			String annotName = annotations.get(0).getNameAsString();
			if( annotName.equalsIgnoreCase("JsonNotification")) {
				return true;
			}
		}
		return false;
	}

	private boolean isRequest(MethodDeclaration dec) {
		NodeList<AnnotationExpr> annotations = dec.getAnnotations();
		for( AnnotationExpr a : annotations) {
			String annotName = annotations.get(0).getNameAsString();
			if( annotName.equalsIgnoreCase("JsonRequest")) {
				return true;
			}
		}
		return false;
	}

	
	private void printOneRequest(String methodName, JavadocComment jdc, 
			StringBuffer sb, String serverOrClient) {
		if( jdc != null ) {
			String comment = jdc.getContent().substring(1);
			sb.append("        /**\n");
			sb.append(comment.replaceAll("\t", "        "));
			sb.append("*/");
			sb.append("\n        export namespace ");
			sb.append(methodNameToRequestName(methodName));
			sb.append(" {\n");
			
			// TODO body
			MethodDeclaration md = getMethodDeclaration(jdc);
			sb.append("            export const type = new RequestType<");
			NodeList<Parameter> params = md.getParameters();
			if( params.size() == 0 ) {
				sb.append("void, ");
			} else {
				Type type = params.get(0).getType();
				String typeName = type.toString();
				if( typeName.equalsIgnoreCase("void")) 
					sb.append("void, ");
				else 
					sb.append("Protocol." + typeName + ", ");

			}
			
			Type retType = md.getType();
			String retTypeName = convertReturnType(retType.toString());
			sb.append(retTypeName);
			sb.append(", void, void>('" + serverOrClient + "/" + methodName + "');");
			sb.append("\n");
			sb.append("        }\n");
		}
	}

	private String methodNameToNotificationName(String methodName) {
		return capFirstLetter(methodName) + "Notification";	
	}
	
	private String methodNameToRequestName(String methodName) {
		return capFirstLetter(methodName) + "Request";
	}
	
	private String capFirstLetter(String s) {
		return s.substring(0, 1).toUpperCase() + s.substring(1);
	}
	
	private void printOneNotification(String methodName, JavadocComment jdc, 
			StringBuffer sb, String serverOrClient) {
		if( jdc != null ) {
			String comment = jdc.getContent().substring(1);
			sb.append("        /**\n");
			sb.append(comment.replaceAll("\t", "        "));
			sb.append("*/");
			sb.append("\n        export namespace ");
			sb.append(methodNameToNotificationName(methodName));
			sb.append(" {\n");
			
			// TODO body
			MethodDeclaration md = getMethodDeclaration(jdc);
			sb.append("            export const type = new NotificationType<");
			NodeList<Parameter> params = md.getParameters();
			if( params.size() == 0 ) {
				sb.append("void, ");
			} else {
				Type type = params.get(0).getType();
				String typeName = type.toString();
				if( typeName.equalsIgnoreCase("void")) 
					sb.append("void, ");
				else 
					sb.append("Protocol." + typeName + ", ");
			}
			
			Type retType = md.getType();
			String retTypeName = convertReturnType(retType.toString());
			sb.append(retTypeName);
			sb.append(">('" + serverOrClient + "/" + methodName + "');");
			sb.append("\n");
			sb.append("        }\n");
		}
	}

	private String convertReturnType(String type) {
		if( type.startsWith("CompletableFuture<") && type.endsWith(">")) {
			type = type.substring("CompletableFuture<".length());
			type = type.substring(0, type.length()-1);
		}
		if( type.startsWith("List<")) {
			type = "Array<Protocol." + type.substring("List<".length());
		} else {
			if( type.equals("String"))
				type = "string";
			else if( !type.equalsIgnoreCase("void")) 
				type = "Protocol." + type;
			
		}
		return type;
	}

	private MethodDeclaration getMethodDeclaration(JavadocComment comment) {
		Optional<Node> o = comment.getCommentedNode();
		if (o.get() != null) {
			if (!(o.get() instanceof CompilationUnit)) {
				Node n = o.get();
				if (n instanceof MethodDeclaration) {
					return (MethodDeclaration) n;
				}
			}
		}
		return null;
	}
	
	private String messageTsFooter() {
		return "}\n";
	}
	
	private File getClientInterfaceFile() throws IOException {
		File f2 = new File(baseDir);
		File f = new File(f2, "../../bundles/org.jboss.tools.rsp.api/src/main/java/org/jboss/tools/rsp/api/RSPClient.java").getCanonicalFile();
		return f;
	}

	private File getServerInterfaceFile() throws IOException {
		File f2 = new File(baseDir);
		File f = new File(f2, "../../bundles/org.jboss.tools.rsp.api/src/main/java/org/jboss/tools/rsp/api/RSPServer.java").getCanonicalFile();
		return f;
	}
	private static String linePrefix(String original, String prefix ) {
		String before = original;
		String after = ("\n" + original).replace("\n", "\n" + prefix).substring(1);
		return after;
	}
	
	private static String readFile(File file) {
		String content = "";
		try {
			content = new String(Files.readAllBytes(file.toPath()));
		} catch (IOException e) {
		}
		return content;
	}
	
	private HashMap<String, JavadocComment> methodToJavadocMap(File f) {
		HashMap<String, JavadocComment> map = new LinkedHashMap<>();
		VoidVisitorAdapter adapter = new VoidVisitorAdapter<Object>() {
			@Override
			public void visit(JavadocComment comment, Object arg) {
				super.visit(comment, arg);
				Optional<Node> o = comment.getCommentedNode();
				if (o.get() != null) {
					if (!(o.get() instanceof CompilationUnit)) {
						Node n = o.get();
						if (n instanceof MethodDeclaration) {
							map.put(((MethodDeclaration)n).getNameAsString(), comment);
						}
					}
				}
			}
		};
		try {
			CompilationUnit cu = JavaParser.parse(f);
			adapter.visit(cu, null);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return map;
	}
}
